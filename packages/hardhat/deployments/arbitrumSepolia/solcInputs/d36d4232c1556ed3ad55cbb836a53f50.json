{
  "language": "Solidity",
  "sources": {
    "contracts/BrandCrusherV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract BrandCrusherV2 {\n    // Core structures\n    struct Advertisement {\n        address advertiser;\n        uint256 amount;          // Amount paid in ETH\n        string adContent;       // IPFS hash or URL\n        string brandName;\n        uint256 timestamp;\n        bool isActive;\n        uint256 roundId;\n    }\n    \n    struct GameRound {\n        uint256 roundId;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 totalAdPool;\n        uint256 prizePool;       // 70% of totalAdPool\n        uint256 platformFee;     // 30% of totalAdPool\n        address winner;\n        uint256 winningScore;\n        bool isActive;\n        uint256 playerCount;\n    }\n    \n    struct PlayerScore {\n        address player;\n        uint256 score;\n        uint256 roundId;\n        bool civicVerified;\n        uint256 timestamp;\n    }\n    \n    struct PlayerStats {\n        uint256 totalGames;\n        uint256 highScore;\n        uint256 totalScore;\n        bool civicVerified;\n        uint256 totalWinnings;\n    }\n    \n    // State variables\n    mapping(uint256 => GameRound) public rounds;\n    mapping(uint256 => PlayerScore[]) public roundScores;\n    mapping(uint256 => Advertisement[]) public roundAds;\n    mapping(address => PlayerStats) public playerStats;\n    mapping(address => uint256) public playerBalances;\n    \n    // Round management\n    uint256 public currentRoundId;\n    uint256 public constant ROUND_DURATION = 300; // 5 minutes in seconds\n    uint256 public constant MIN_AD_PRICE = 0.0003 ether;  // ~$1\n    uint256 public constant MIN_PRIZE_POOL = 0.003 ether; // ~$10\n    uint256 public constant PRIZE_PERCENTAGE = 70;\n    uint256 public constant PLATFORM_FEE_PERCENTAGE = 30;\n    uint256 public constant CIVIC_BONUS_MULTIPLIER = 150; // 1.5x = 150%\n    uint256 public constant BASE_MULTIPLIER = 100;\n    \n    address public owner;\n    uint256 public totalPlatformFees;\n    \n    // Events\n    event AdRegistered(address indexed advertiser, uint256 amount, uint256 roundId, string brandName);\n    event RoundStarted(uint256 indexed roundId, uint256 startTime, uint256 endTime);\n    event ScoreSubmitted(address indexed player, uint256 score, uint256 roundId, bool civicVerified);\n    event RoundEnded(uint256 indexed roundId, address winner, uint256 prize, uint256 platformFee);\n    event PrizeClaimed(address indexed winner, uint256 amount);\n    event PlatformFeeCollected(uint256 amount);\n    event CivicVerificationUpdated(address indexed player, bool verified);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n    \n    modifier onlyActiveRound() {\n        require(rounds[currentRoundId].isActive, \"No active round\");\n        require(block.timestamp <= rounds[currentRoundId].endTime, \"Round has ended\");\n        _;\n    }\n    \n    constructor() {\n        owner = msg.sender;\n        _startNewRound();\n    }\n    \n    // Register advertisement with payment\n    function registerAdvertisement(\n        string memory _brandName,\n        string memory _adContent\n    ) external payable {\n        require(msg.value >= MIN_AD_PRICE, \"Payment below minimum\");\n        require(rounds[currentRoundId].isActive, \"No active round\");\n        require(block.timestamp <= rounds[currentRoundId].endTime, \"Round has ended\");\n        \n        // Create advertisement\n        Advertisement memory newAd = Advertisement({\n            advertiser: msg.sender,\n            amount: msg.value,\n            adContent: _adContent,\n            brandName: _brandName,\n            timestamp: block.timestamp,\n            isActive: true,\n            roundId: currentRoundId\n        });\n        \n        // Add to current round\n        roundAds[currentRoundId].push(newAd);\n        rounds[currentRoundId].totalAdPool += msg.value;\n        \n        // Calculate prize pool (70% of ad payment)\n        uint256 prizeContribution = (msg.value * PRIZE_PERCENTAGE) / 100;\n        uint256 platformContribution = (msg.value * PLATFORM_FEE_PERCENTAGE) / 100;\n        \n        rounds[currentRoundId].prizePool += prizeContribution;\n        rounds[currentRoundId].platformFee += platformContribution;\n        \n        emit AdRegistered(msg.sender, msg.value, currentRoundId, _brandName);\n    }\n    \n    // Submit score during active round\n    function submitScore(\n        uint256 _score,\n        bool _civicVerified,\n        string memory _playerName\n    ) external onlyActiveRound returns (uint256 finalScore) {\n        require(_score > 0, \"Score must be positive\");\n        \n        // Calculate final score with Civic bonus\n        if (_civicVerified) {\n            finalScore = (_score * CIVIC_BONUS_MULTIPLIER) / BASE_MULTIPLIER;\n        } else {\n            finalScore = _score;\n        }\n        \n        // Create player score record\n        PlayerScore memory newScore = PlayerScore({\n            player: msg.sender,\n            score: finalScore,\n            roundId: currentRoundId,\n            civicVerified: _civicVerified,\n            timestamp: block.timestamp\n        });\n        \n        // Add to round scores\n        roundScores[currentRoundId].push(newScore);\n        rounds[currentRoundId].playerCount++;\n        \n        // Update player stats\n        PlayerStats storage stats = playerStats[msg.sender];\n        stats.totalGames++;\n        stats.totalScore += finalScore;\n        stats.civicVerified = _civicVerified;\n        \n        if (finalScore > stats.highScore) {\n            stats.highScore = finalScore;\n        }\n        \n        emit ScoreSubmitted(msg.sender, _score, currentRoundId, _civicVerified);\n        \n        return finalScore;\n    }\n    \n    // End current round and determine winner\n    function endRound() external {\n        require(rounds[currentRoundId].isActive, \"No active round\");\n        require(\n            block.timestamp > rounds[currentRoundId].endTime || \n            rounds[currentRoundId].playerCount > 0,\n            \"Round not ready to end\"\n        );\n        \n        GameRound storage round = rounds[currentRoundId];\n        round.isActive = false;\n        \n        // Find winner if there are players\n        if (round.playerCount > 0 && round.prizePool > 0) {\n            PlayerScore[] memory scores = roundScores[currentRoundId];\n            address winner = address(0);\n            uint256 highestScore = 0;\n            \n            for (uint256 i = 0; i < scores.length; i++) {\n                if (scores[i].score > highestScore) {\n                    highestScore = scores[i].score;\n                    winner = scores[i].player;\n                }\n            }\n            \n            if (winner != address(0)) {\n                round.winner = winner;\n                round.winningScore = highestScore;\n                \n                // Transfer prize to winner\n                playerBalances[winner] += round.prizePool;\n                playerStats[winner].totalWinnings += round.prizePool;\n                \n                emit PrizeClaimed(winner, round.prizePool);\n            }\n        }\n        \n        // Collect platform fee\n        if (round.platformFee > 0) {\n            totalPlatformFees += round.platformFee;\n            emit PlatformFeeCollected(round.platformFee);\n        }\n        \n        emit RoundEnded(currentRoundId, round.winner, round.prizePool, round.platformFee);\n        \n        // Start new round\n        _startNewRound();\n    }\n    \n    // Start new round\n    function _startNewRound() internal {\n        currentRoundId++;\n        rounds[currentRoundId] = GameRound({\n            roundId: currentRoundId,\n            startTime: block.timestamp,\n            endTime: block.timestamp + ROUND_DURATION,\n            totalAdPool: 0,\n            prizePool: 0,\n            platformFee: 0,\n            winner: address(0),\n            winningScore: 0,\n            isActive: true,\n            playerCount: 0\n        });\n        \n        emit RoundStarted(currentRoundId, block.timestamp, block.timestamp + ROUND_DURATION);\n    }\n    \n    // Claim prize (if any)\n    function claimPrize() external {\n        uint256 amount = playerBalances[msg.sender];\n        require(amount > 0, \"No prize to claim\");\n        \n        playerBalances[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n        \n        emit PrizeClaimed(msg.sender, amount);\n    }\n    \n    // Update Civic verification status\n    function updateCivicVerification(bool verified) external {\n        playerStats[msg.sender].civicVerified = verified;\n        emit CivicVerificationUpdated(msg.sender, verified);\n    }\n    \n    // View functions\n    function getCurrentPrizePool() external view returns (uint256) {\n        return rounds[currentRoundId].prizePool;\n    }\n    \n    function getCurrentRoundInfo() external view returns (\n        uint256 roundId,\n        uint256 startTime,\n        uint256 endTime,\n        uint256 totalAdPool,\n        uint256 prizePool,\n        uint256 playerCount,\n        bool isActive\n    ) {\n        GameRound memory round = rounds[currentRoundId];\n        return (\n            round.roundId,\n            round.startTime,\n            round.endTime,\n            round.totalAdPool,\n            round.prizePool,\n            round.playerCount,\n            round.isActive\n        );\n    }\n    \n    function getRoundDifficulty(uint256 _roundId) external view returns (string memory) {\n        GameRound memory round = rounds[_roundId];\n        if (round.totalAdPool == 0) return \"Easy\";\n        if (round.totalAdPool < 0.001 ether) return \"Medium\";\n        if (round.totalAdPool < 0.01 ether) return \"Hard\";\n        return \"EXTREME\";\n    }\n    \n    function getActivePlayersCount() external view returns (uint256) {\n        return rounds[currentRoundId].playerCount;\n    }\n    \n    function getRoundAds(uint256 _roundId) external view returns (Advertisement[] memory) {\n        return roundAds[_roundId];\n    }\n    \n    function getRoundScores(uint256 _roundId) external view returns (PlayerScore[] memory) {\n        return roundScores[_roundId];\n    }\n    \n    function getPlayerStats(address player) external view returns (PlayerStats memory) {\n        return playerStats[player];\n    }\n    \n    function getPlayerBalance(address player) external view returns (uint256) {\n        return playerBalances[player];\n    }\n    \n    // Emergency functions (owner only)\n    function pauseRound() external onlyOwner {\n        rounds[currentRoundId].isActive = false;\n    }\n    \n    function withdrawPlatformFees() external onlyOwner {\n        uint256 amount = totalPlatformFees;\n        totalPlatformFees = 0;\n        payable(owner).transfer(amount);\n    }\n    \n    // Fallback to receive ETH\n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}